/**
 * GITHUB EXECUTOR
 *
 * Pushes generated code to GitHub.
 * Uses the user's GitHub OAuth token from Supabase session.
 *
 * This is the final step - delivering the project to the user's GitHub.
 */

import {
  createRepository,
  pushFiles,
  getGitHubConnectionStatus,
  validateGitHubToken,
  listUserRepos,
} from '../../../lib/connectors/github';
import type { GitHubRepo } from '../../../lib/connectors/types';
import { GeneratedFile, ProjectPlan, AgentStreamCallback } from '../../core/types';
import { logger } from '@/lib/logger';

const log = logger('GitHubExecutor');

export interface GitHubPushResult {
  success: boolean;
  repoUrl?: string;
  commitSha?: string;
  error?: string;
}

export class GitHubExecutor {
  private token: string | null = null;
  private username: string | null = null;

  /**
   * Initialize with user's GitHub token
   */
  async initialize(token: string): Promise<boolean> {
    if (!token) {
      log.warn('No token provided');
      return false;
    }

    // Validate the token
    const isValid = await validateGitHubToken(token);
    if (!isValid) {
      log.warn('Invalid token');
      return false;
    }

    // Get user info
    const status = await getGitHubConnectionStatus(token);
    if (status.status !== 'connected' || !status.metadata?.username) {
      log.warn('Failed to get user info');
      return false;
    }

    this.token = token;
    this.username = status.metadata.username;
    return true;
  }

  /**
   * Check if GitHub is available
   */
  isAvailable(): boolean {
    return this.token !== null && this.username !== null;
  }

  /**
   * Get the connected username
   */
  getUsername(): string | null {
    return this.username;
  }

  /**
   * Push all files to a new or existing repository
   */
  async push(
    files: GeneratedFile[],
    plan: ProjectPlan,
    options: {
      createNew?: boolean;
      repoName?: string;
      private?: boolean;
      branch?: string;
    } = {},
    onStream?: AgentStreamCallback
  ): Promise<GitHubPushResult> {
    if (!this.token || !this.username) {
      return {
        success: false,
        error: 'GitHub not connected. Please login with GitHub first.',
      };
    }

    const repoName = options.repoName || plan.name;
    const branch = options.branch || 'main';

    onStream?.({
      type: 'synthesizing',
      message: `Pushing to GitHub: ${this.username}/${repoName}...`,
      phase: 'GitHub Push',
      progress: 90,
      timestamp: Date.now(),
    });

    try {
      let targetRepo: GitHubRepo | null = null;

      if (options.createNew !== false) {
        // Try to create a new repository
        targetRepo = await createRepository(this.token, {
          name: repoName,
          description: plan.description,
          private: options.private ?? false,
          autoInit: true,
        });

        if (!targetRepo) {
          // Repo might already exist, try to use it
          const repos = await listUserRepos(this.token);
          targetRepo = repos.find((r) => r.name === repoName) || null;

          if (!targetRepo) {
            return {
              success: false,
              error: `Failed to create or find repository: ${repoName}`,
            };
          }
        }
      } else {
        // Use existing repo
        const repos = await listUserRepos(this.token);
        targetRepo = repos.find((r) => r.name === repoName) || null;

        if (!targetRepo) {
          return {
            success: false,
            error: `Repository not found: ${repoName}`,
          };
        }
      }

      // Convert files to GitHub format
      const githubFiles = files.map((f) => ({
        path: f.path,
        content: f.content,
      }));

      // Push all files
      const pushResult = await pushFiles(this.token, {
        owner: this.username,
        repo: repoName,
        branch,
        message: `Initial commit: ${plan.description}\n\nGenerated by JCIL Code Agent`,
        files: githubFiles,
      });

      if (!pushResult.success) {
        return {
          success: false,
          error: pushResult.error || 'Push failed',
        };
      }

      return {
        success: true,
        repoUrl: `https://github.com/${this.username}/${repoName}`,
        commitSha: pushResult.commitSha,
      };
    } catch (error) {
      log.error('Push failed', { error: (error as Error).message });
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Push failed',
      };
    }
  }

  /**
   * Check if a repository name is available
   */
  async isRepoNameAvailable(name: string): Promise<boolean> {
    if (!this.token) return false;

    try {
      const repos = await listUserRepos(this.token);
      return !repos.some((r) => r.name.toLowerCase() === name.toLowerCase());
    } catch {
      return true; // Assume available if we can't check
    }
  }

  /**
   * Suggest a unique repository name
   */
  async suggestRepoName(baseName: string): Promise<string> {
    if (!this.token) return baseName;

    const isAvailable = await this.isRepoNameAvailable(baseName);
    if (isAvailable) return baseName;

    // Add timestamp suffix
    const timestamp = Date.now().toString(36);
    return `${baseName}-${timestamp}`;
  }

  /**
   * List user's repositories
   */
  async listRepos(): Promise<GitHubRepo[]> {
    if (!this.token) return [];
    return listUserRepos(this.token);
  }
}

export const githubExecutor = new GitHubExecutor();
