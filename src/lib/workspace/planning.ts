/**
 * CODE LAB PLANNING MODE
 *
 * Provides Claude Code-like planning capabilities:
 * - Enter plan mode for complex tasks
 * - Write plans to a plan file
 * - Exit plan mode with user approval
 */

export interface PlanTask {
  id: string;
  title: string;
  description: string;
  status: 'pending' | 'in_progress' | 'completed' | 'blocked';
  subtasks?: PlanTask[];
  dependencies?: string[];
  estimatedComplexity?: 'low' | 'medium' | 'high';
}

export interface Plan {
  id: string;
  sessionId: string;
  title: string;
  summary: string;
  tasks: PlanTask[];
  status: 'draft' | 'awaiting_approval' | 'approved' | 'in_progress' | 'completed' | 'rejected';
  createdAt: string;
  updatedAt: string;
  approvedAt?: string;
  completedAt?: string;
  notes?: string;
}

export interface PlanModeState {
  isActive: boolean;
  planId?: string;
  planFilePath?: string;
  exploration: {
    filesExplored: string[];
    patternsFound: string[];
    questions: string[];
  };
}

/**
 * Generate a unique plan ID
 */
export function generatePlanId(): string {
  return `plan-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Generate a unique task ID
 */
export function generateTaskId(): string {
  return `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Format a plan as markdown for the plan file
 */
export function formatPlanAsMarkdown(plan: Plan): string {
  const lines: string[] = [
    `# ${plan.title}`,
    '',
    `**Status:** ${plan.status}`,
    `**Created:** ${new Date(plan.createdAt).toLocaleString()}`,
    `**Updated:** ${new Date(plan.updatedAt).toLocaleString()}`,
    '',
    '## Summary',
    '',
    plan.summary,
    '',
    '## Tasks',
    '',
  ];

  const formatTask = (task: PlanTask, indent: number = 0): void => {
    const prefix = '  '.repeat(indent);
    const checkbox = task.status === 'completed' ? '[x]' : task.status === 'in_progress' ? '[~]' : task.status === 'blocked' ? '[!]' : '[ ]';
    const complexity = task.estimatedComplexity ? ` (${task.estimatedComplexity})` : '';

    lines.push(`${prefix}- ${checkbox} **${task.title}**${complexity}`);
    if (task.description) {
      lines.push(`${prefix}  ${task.description}`);
    }
    if (task.dependencies && task.dependencies.length > 0) {
      lines.push(`${prefix}  *Dependencies:* ${task.dependencies.join(', ')}`);
    }
    if (task.subtasks) {
      task.subtasks.forEach(st => formatTask(st, indent + 1));
    }
  };

  plan.tasks.forEach(task => formatTask(task));

  if (plan.notes) {
    lines.push('', '## Notes', '', plan.notes);
  }

  lines.push('', '---', '', '*This plan was generated by Code Lab Planning Mode.*');

  return lines.join('\n');
}

/**
 * Parse a markdown plan file back into a Plan object
 */
export function parsePlanFromMarkdown(markdown: string, planId: string, sessionId: string): Plan {
  const lines = markdown.split('\n');
  const plan: Plan = {
    id: planId,
    sessionId,
    title: 'Untitled Plan',
    summary: '',
    tasks: [],
    status: 'draft',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  let section = '';
  let summaryLines: string[] = [];

  for (const line of lines) {
    // Parse title
    if (line.startsWith('# ')) {
      plan.title = line.substring(2).trim();
      continue;
    }

    // Parse status
    if (line.startsWith('**Status:**')) {
      const status = line.replace('**Status:**', '').trim().toLowerCase();
      if (['draft', 'awaiting_approval', 'approved', 'in_progress', 'completed', 'rejected'].includes(status)) {
        plan.status = status as Plan['status'];
      }
      continue;
    }

    // Track sections
    if (line.startsWith('## ')) {
      section = line.substring(3).trim().toLowerCase();
      continue;
    }

    // Parse summary
    if (section === 'summary' && line.trim()) {
      summaryLines.push(line);
    }

    // Parse tasks
    if (section === 'tasks' && line.trim().startsWith('-')) {
      const match = line.match(/^(\s*)-\s*\[([ x~!])\]\s*\*\*(.+?)\*\*(?:\s*\((.+?)\))?/);
      if (match) {
        const [, indent, checkChar, title, complexity] = match;
        const status = checkChar === 'x' ? 'completed' : checkChar === '~' ? 'in_progress' : checkChar === '!' ? 'blocked' : 'pending';

        const task: PlanTask = {
          id: generateTaskId(),
          title: title.trim(),
          description: '',
          status: status as PlanTask['status'],
          estimatedComplexity: complexity as PlanTask['estimatedComplexity'],
        };

        // Simple depth tracking (tasks with indent go as subtasks of previous)
        if (indent.length === 0) {
          plan.tasks.push(task);
        } else if (plan.tasks.length > 0) {
          const lastTask = plan.tasks[plan.tasks.length - 1];
          if (!lastTask.subtasks) lastTask.subtasks = [];
          lastTask.subtasks.push(task);
        }
      }
    }
  }

  plan.summary = summaryLines.join('\n');

  return plan;
}

/**
 * Create the plan mode tools for the workspace agent
 */
export function getPlanModeTools() {
  return [
    {
      name: 'enter_plan_mode',
      description: `Enter planning mode for complex tasks that require careful design before implementation. Use this when:
- The task has multiple valid approaches with trade-offs
- Significant architectural decisions are needed
- The change touches many files or systems
- Requirements are unclear and need exploration
- You would need to ask clarifying questions

In plan mode, you'll explore the codebase, design an approach, and present a plan for user approval before implementing.`,
      input_schema: {
        type: 'object' as const,
        properties: {
          reason: {
            type: 'string',
            description: 'Brief explanation of why planning mode is needed for this task',
          },
          initial_questions: {
            type: 'array',
            items: { type: 'string' },
            description: 'Initial questions or areas to explore',
          },
        },
        required: ['reason'],
      },
    },
    {
      name: 'write_plan',
      description: 'Write or update the implementation plan. Call this after exploring the codebase to document your proposed approach.',
      input_schema: {
        type: 'object' as const,
        properties: {
          title: {
            type: 'string',
            description: 'Plan title (short description of the task)',
          },
          summary: {
            type: 'string',
            description: 'Summary of the implementation approach',
          },
          tasks: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                title: { type: 'string' },
                description: { type: 'string' },
                complexity: { type: 'string', enum: ['low', 'medium', 'high'] },
              },
              required: ['title'],
            },
            description: 'List of implementation tasks in order',
          },
          notes: {
            type: 'string',
            description: 'Additional notes, trade-offs, or considerations',
          },
        },
        required: ['title', 'summary', 'tasks'],
      },
    },
    {
      name: 'exit_plan_mode',
      description: 'Exit planning mode and request user approval. Call this after writing a complete plan. The user will review and approve before implementation begins.',
      input_schema: {
        type: 'object' as const,
        properties: {
          ready_for_approval: {
            type: 'boolean',
            description: 'Set to true when plan is complete and ready for review',
          },
          questions_for_user: {
            type: 'array',
            items: { type: 'string' },
            description: 'Any remaining questions for the user before proceeding',
          },
        },
        required: ['ready_for_approval'],
      },
    },
  ];
}

/**
 * Plan mode state manager
 */
export class PlanModeManager {
  private state: PlanModeState = {
    isActive: false,
    exploration: {
      filesExplored: [],
      patternsFound: [],
      questions: [],
    },
  };

  private currentPlan: Plan | null = null;

  isInPlanMode(): boolean {
    return this.state.isActive;
  }

  enterPlanMode(sessionId: string, reason: string, initialQuestions?: string[]): { success: boolean; planId: string; message: string } {
    if (this.state.isActive) {
      return {
        success: false,
        planId: this.state.planId || '',
        message: 'Already in plan mode. Use exit_plan_mode first to exit.',
      };
    }

    const planId = generatePlanId();
    const planFilePath = `/workspace/.claude/plans/${planId}.md`;

    this.state = {
      isActive: true,
      planId,
      planFilePath,
      exploration: {
        filesExplored: [],
        patternsFound: [],
        questions: initialQuestions || [],
      },
    };

    this.currentPlan = {
      id: planId,
      sessionId,
      title: 'Implementation Plan',
      summary: reason,
      tasks: [],
      status: 'draft',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    return {
      success: true,
      planId,
      message: `Entered plan mode. Plan ID: ${planId}

You are now in planning mode. Your goal is to:
1. Explore the codebase to understand existing patterns
2. Design an implementation approach
3. Write a plan using write_plan
4. Exit with exit_plan_mode when ready for approval

Plan will be saved to: ${planFilePath}`,
    };
  }

  writePlan(
    title: string,
    summary: string,
    tasks: Array<{ title: string; description?: string; complexity?: string }>,
    notes?: string
  ): { success: boolean; planContent: string; message: string } {
    if (!this.state.isActive || !this.currentPlan) {
      return {
        success: false,
        planContent: '',
        message: 'Not in plan mode. Use enter_plan_mode first.',
      };
    }

    // Update the current plan
    this.currentPlan.title = title;
    this.currentPlan.summary = summary;
    this.currentPlan.tasks = tasks.map(t => ({
      id: generateTaskId(),
      title: t.title,
      description: t.description || '',
      status: 'pending' as const,
      estimatedComplexity: (t.complexity as PlanTask['estimatedComplexity']) || undefined,
    }));
    this.currentPlan.notes = notes;
    this.currentPlan.updatedAt = new Date().toISOString();

    const planContent = formatPlanAsMarkdown(this.currentPlan);

    return {
      success: true,
      planContent,
      message: `Plan updated successfully.

**${title}**

Tasks:
${tasks.map((t, i) => `${i + 1}. ${t.title}${t.complexity ? ` (${t.complexity})` : ''}`).join('\n')}

Use exit_plan_mode when ready for user approval.`,
    };
  }

  exitPlanMode(
    readyForApproval: boolean,
    questionsForUser?: string[]
  ): { success: boolean; plan: Plan | null; message: string } {
    if (!this.state.isActive || !this.currentPlan) {
      return {
        success: false,
        plan: null,
        message: 'Not in plan mode.',
      };
    }

    if (!readyForApproval) {
      return {
        success: true,
        plan: this.currentPlan,
        message: 'Plan mode active. Set ready_for_approval=true when plan is complete.',
      };
    }

    // Update plan status
    this.currentPlan.status = 'awaiting_approval';
    this.currentPlan.updatedAt = new Date().toISOString();

    const plan = this.currentPlan;

    // Reset state
    this.state = {
      isActive: false,
      exploration: {
        filesExplored: [],
        patternsFound: [],
        questions: [],
      },
    };

    let message = `**Plan ready for approval**

${plan.title}

${plan.summary}

**${plan.tasks.length} tasks planned**

`;

    if (questionsForUser && questionsForUser.length > 0) {
      message += `\n**Questions for user:**\n${questionsForUser.map(q => `- ${q}`).join('\n')}\n`;
    }

    message += '\n[AWAITING_USER_APPROVAL]';

    return {
      success: true,
      plan,
      message,
    };
  }

  addExploredFile(filePath: string): void {
    if (this.state.isActive && !this.state.exploration.filesExplored.includes(filePath)) {
      this.state.exploration.filesExplored.push(filePath);
    }
  }

  addFoundPattern(pattern: string): void {
    if (this.state.isActive && !this.state.exploration.patternsFound.includes(pattern)) {
      this.state.exploration.patternsFound.push(pattern);
    }
  }

  getCurrentPlan(): Plan | null {
    return this.currentPlan;
  }

  getState(): PlanModeState {
    return { ...this.state };
  }
}

// Singleton instance
let planModeManager: PlanModeManager | null = null;

export function getPlanModeManager(): PlanModeManager {
  if (!planModeManager) {
    planModeManager = new PlanModeManager();
  }
  return planModeManager;
}
