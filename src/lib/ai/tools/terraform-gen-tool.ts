/**
 * TERRAFORM GENERATOR TOOL
 * Generate Terraform/OpenTofu infrastructure code
 */

import type { UnifiedTool, UnifiedToolCall, UnifiedToolResult } from '../providers/types';

function generateAWSInfra(config: {
  name: string;
  region?: string;
  resources: Array<{
    type: 'vpc' | 'ec2' | 's3' | 'rds' | 'lambda' | 'ecs' | 'eks' | 'elb' | 'cloudfront';
    name: string;
    config?: Record<string, unknown>;
  }>;
}): string {
  const { name, region = 'us-east-1', resources } = config;

  let tf = `# Terraform configuration for ${name}
# Generated by Terraform Generator Tool

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "${region}"

  default_tags {
    tags = {
      Project     = "${name}"
      Environment = var.environment
      ManagedBy   = "Terraform"
    }
  }
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

`;

  for (const resource of resources) {
    switch (resource.type) {
      case 'vpc':
        tf += generateVPC(resource.name);
        break;
      case 'ec2':
        tf += generateEC2(resource.name, resource.config);
        break;
      case 's3':
        tf += generateS3(resource.name, resource.config);
        break;
      case 'rds':
        tf += generateRDS(resource.name, resource.config);
        break;
      case 'lambda':
        tf += generateLambda(resource.name, resource.config);
        break;
      case 'ecs':
        tf += generateECS(resource.name, resource.config);
        break;
      case 'eks':
        tf += generateEKS(resource.name, resource.config);
        break;
      case 'elb':
        tf += generateELB(resource.name, resource.config);
        break;
      case 'cloudfront':
        tf += generateCloudFront(resource.name, resource.config);
        break;
    }
  }

  return tf;
}

function generateVPC(name: string): string {
  return `
# VPC
resource "aws_vpc" "${name}" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${name}"
  }
}

resource "aws_subnet" "${name}_public_1" {
  vpc_id                  = aws_vpc.${name}.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = data.aws_availability_zones.available.names[0]
  map_public_ip_on_launch = true

  tags = {
    Name = "${name}-public-1"
    Type = "public"
  }
}

resource "aws_subnet" "${name}_public_2" {
  vpc_id                  = aws_vpc.${name}.id
  cidr_block              = "10.0.2.0/24"
  availability_zone       = data.aws_availability_zones.available.names[1]
  map_public_ip_on_launch = true

  tags = {
    Name = "${name}-public-2"
    Type = "public"
  }
}

resource "aws_subnet" "${name}_private_1" {
  vpc_id            = aws_vpc.${name}.id
  cidr_block        = "10.0.10.0/24"
  availability_zone = data.aws_availability_zones.available.names[0]

  tags = {
    Name = "${name}-private-1"
    Type = "private"
  }
}

resource "aws_subnet" "${name}_private_2" {
  vpc_id            = aws_vpc.${name}.id
  cidr_block        = "10.0.11.0/24"
  availability_zone = data.aws_availability_zones.available.names[1]

  tags = {
    Name = "${name}-private-2"
    Type = "private"
  }
}

resource "aws_internet_gateway" "${name}" {
  vpc_id = aws_vpc.${name}.id

  tags = {
    Name = "${name}"
  }
}

resource "aws_route_table" "${name}_public" {
  vpc_id = aws_vpc.${name}.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.${name}.id
  }

  tags = {
    Name = "${name}-public"
  }
}

data "aws_availability_zones" "available" {
  state = "available"
}

`;
}

function generateEC2(name: string, config?: Record<string, unknown>): string {
  const instanceType = (config?.instanceType as string) || 't3.micro';
  const ami = (config?.ami as string) || 'ami-0c55b159cbfafe1f0';

  return `
# EC2 Instance
resource "aws_instance" "${name}" {
  ami           = "${ami}"
  instance_type = "${instanceType}"

  vpc_security_group_ids = [aws_security_group.${name}_sg.id]

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
    encrypted   = true
  }

  metadata_options {
    http_endpoint               = "enabled"
    http_tokens                 = "required"
    http_put_response_hop_limit = 1
  }

  tags = {
    Name = "${name}"
  }
}

resource "aws_security_group" "${name}_sg" {
  name        = "${name}-sg"
  description = "Security group for ${name}"

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${name}-sg"
  }
}

`;
}

function generateS3(name: string, config?: Record<string, unknown>): string {
  const versioning = config?.versioning !== false;

  return `
# S3 Bucket
resource "aws_s3_bucket" "${name}" {
  bucket = "${name}-\${var.environment}"

  tags = {
    Name = "${name}"
  }
}

resource "aws_s3_bucket_versioning" "${name}" {
  bucket = aws_s3_bucket.${name}.id
  versioning_configuration {
    status = "${versioning ? 'Enabled' : 'Disabled'}"
  }
}

resource "aws_s3_bucket_server_side_encryption_configuration" "${name}" {
  bucket = aws_s3_bucket.${name}.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

resource "aws_s3_bucket_public_access_block" "${name}" {
  bucket = aws_s3_bucket.${name}.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

`;
}

function generateRDS(name: string, config?: Record<string, unknown>): string {
  const engine = (config?.engine as string) || 'postgres';
  const instanceClass = (config?.instanceClass as string) || 'db.t3.micro';

  return `
# RDS Database
resource "aws_db_instance" "${name}" {
  identifier     = "${name}-\${var.environment}"
  engine         = "${engine}"
  engine_version = "${engine === 'postgres' ? '15' : '8.0'}"
  instance_class = "${instanceClass}"

  allocated_storage     = 20
  max_allocated_storage = 100
  storage_type          = "gp3"
  storage_encrypted     = true

  db_name  = "${name.replace(/-/g, '_')}"
  username = "admin"
  password = var.db_password

  multi_az               = var.environment == "prod"
  publicly_accessible    = false
  deletion_protection    = var.environment == "prod"
  skip_final_snapshot    = var.environment != "prod"
  final_snapshot_identifier = "${name}-final-snapshot"

  backup_retention_period = 7
  backup_window          = "03:00-04:00"
  maintenance_window     = "Mon:04:00-Mon:05:00"

  performance_insights_enabled = true

  tags = {
    Name = "${name}"
  }
}

variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}

`;
}

function generateLambda(name: string, config?: Record<string, unknown>): string {
  const runtime = (config?.runtime as string) || 'nodejs18.x';
  const memory = (config?.memory as number) || 256;

  return `
# Lambda Function
resource "aws_lambda_function" "${name}" {
  function_name = "${name}-\${var.environment}"
  role          = aws_iam_role.${name}_role.arn
  handler       = "index.handler"
  runtime       = "${runtime}"
  memory_size   = ${memory}
  timeout       = 30

  filename         = data.archive_file.${name}_zip.output_path
  source_code_hash = data.archive_file.${name}_zip.output_base64sha256

  environment {
    variables = {
      ENVIRONMENT = var.environment
    }
  }

  tracing_config {
    mode = "Active"
  }

  tags = {
    Name = "${name}"
  }
}

data "archive_file" "${name}_zip" {
  type        = "zip"
  source_dir  = "\${path.module}/lambda/${name}"
  output_path = "\${path.module}/lambda/${name}.zip"
}

resource "aws_iam_role" "${name}_role" {
  name = "${name}-role-\${var.environment}"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "${name}_basic" {
  role       = aws_iam_role.${name}_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
}

resource "aws_cloudwatch_log_group" "${name}" {
  name              = "/aws/lambda/${name}-\${var.environment}"
  retention_in_days = 14
}

`;
}

function generateECS(name: string, config?: Record<string, unknown>): string {
  const cpu = (config?.cpu as number) || 256;
  const memory = (config?.memory as number) || 512;

  return `
# ECS Cluster and Service
resource "aws_ecs_cluster" "${name}" {
  name = "${name}-\${var.environment}"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }

  tags = {
    Name = "${name}"
  }
}

resource "aws_ecs_task_definition" "${name}" {
  family                   = "${name}"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = ${cpu}
  memory                   = ${memory}
  execution_role_arn       = aws_iam_role.${name}_execution.arn
  task_role_arn           = aws_iam_role.${name}_task.arn

  container_definitions = jsonencode([{
    name  = "${name}"
    image = "\${var.ecr_repository}:latest"

    portMappings = [{
      containerPort = 80
      hostPort      = 80
      protocol      = "tcp"
    }]

    logConfiguration = {
      logDriver = "awslogs"
      options = {
        "awslogs-group"         = aws_cloudwatch_log_group.${name}.name
        "awslogs-region"        = data.aws_region.current.name
        "awslogs-stream-prefix" = "ecs"
      }
    }

    healthCheck = {
      command     = ["CMD-SHELL", "curl -f http://localhost/health || exit 1"]
      interval    = 30
      timeout     = 5
      retries     = 3
      startPeriod = 60
    }
  }])

  tags = {
    Name = "${name}"
  }
}

resource "aws_ecs_service" "${name}" {
  name            = "${name}"
  cluster         = aws_ecs_cluster.${name}.id
  task_definition = aws_ecs_task_definition.${name}.arn
  desired_count   = 2
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = [aws_subnet.private_1.id, aws_subnet.private_2.id]
    security_groups  = [aws_security_group.${name}_ecs.id]
    assign_public_ip = false
  }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  tags = {
    Name = "${name}"
  }
}

resource "aws_cloudwatch_log_group" "${name}" {
  name              = "/ecs/${name}"
  retention_in_days = 14
}

data "aws_region" "current" {}

variable "ecr_repository" {
  description = "ECR repository URL"
  type        = string
}

`;
}

function generateEKS(name: string, config?: Record<string, unknown>): string {
  const version = (config?.version as string) || '1.28';

  return `
# EKS Cluster
resource "aws_eks_cluster" "${name}" {
  name     = "${name}-\${var.environment}"
  role_arn = aws_iam_role.${name}_cluster.arn
  version  = "${version}"

  vpc_config {
    subnet_ids              = [aws_subnet.private_1.id, aws_subnet.private_2.id]
    endpoint_private_access = true
    endpoint_public_access  = true
    security_group_ids      = [aws_security_group.${name}_cluster.id]
  }

  enabled_cluster_log_types = ["api", "audit", "authenticator", "controllerManager", "scheduler"]

  tags = {
    Name = "${name}"
  }

  depends_on = [
    aws_iam_role_policy_attachment.${name}_cluster_policy
  ]
}

resource "aws_eks_node_group" "${name}" {
  cluster_name    = aws_eks_cluster.${name}.name
  node_group_name = "${name}-nodes"
  node_role_arn   = aws_iam_role.${name}_node.arn
  subnet_ids      = [aws_subnet.private_1.id, aws_subnet.private_2.id]

  scaling_config {
    desired_size = 2
    max_size     = 5
    min_size     = 1
  }

  instance_types = ["t3.medium"]

  update_config {
    max_unavailable = 1
  }

  tags = {
    Name = "${name}-nodes"
  }

  depends_on = [
    aws_iam_role_policy_attachment.${name}_node_policy,
    aws_iam_role_policy_attachment.${name}_cni_policy,
    aws_iam_role_policy_attachment.${name}_ecr_policy,
  ]
}

resource "aws_iam_role" "${name}_cluster" {
  name = "${name}-cluster-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "eks.amazonaws.com"
      }
    }]
  })
}

resource "aws_iam_role_policy_attachment" "${name}_cluster_policy" {
  policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
  role       = aws_iam_role.${name}_cluster.name
}

`;
}

function generateELB(name: string, _config?: Record<string, unknown>): string {
  return `
# Application Load Balancer
resource "aws_lb" "${name}" {
  name               = "${name}-\${var.environment}"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.${name}_alb.id]
  subnets            = [aws_subnet.public_1.id, aws_subnet.public_2.id]

  enable_deletion_protection = var.environment == "prod"

  access_logs {
    bucket  = aws_s3_bucket.${name}_logs.bucket
    prefix  = "alb"
    enabled = true
  }

  tags = {
    Name = "${name}"
  }
}

resource "aws_lb_listener" "${name}" {
  load_balancer_arn = aws_lb.${name}.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-TLS13-1-2-2021-06"
  certificate_arn   = var.certificate_arn

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.${name}.arn
  }
}

resource "aws_lb_listener" "${name}_http" {
  load_balancer_arn = aws_lb.${name}.arn
  port              = "80"
  protocol          = "HTTP"

  default_action {
    type = "redirect"
    redirect {
      port        = "443"
      protocol    = "HTTPS"
      status_code = "HTTP_301"
    }
  }
}

resource "aws_lb_target_group" "${name}" {
  name        = "${name}-\${var.environment}"
  port        = 80
  protocol    = "HTTP"
  vpc_id      = aws_vpc.main.id
  target_type = "ip"

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 10
    timeout             = 30
    interval            = 60
    path                = "/health"
    matcher             = "200"
  }

  tags = {
    Name = "${name}"
  }
}

variable "certificate_arn" {
  description = "ACM certificate ARN"
  type        = string
}

`;
}

function generateCloudFront(name: string, _config?: Record<string, unknown>): string {
  return `
# CloudFront Distribution
resource "aws_cloudfront_distribution" "${name}" {
  enabled             = true
  is_ipv6_enabled     = true
  comment             = "${name} distribution"
  default_root_object = "index.html"
  price_class         = "PriceClass_100"

  origin {
    domain_name = aws_s3_bucket.${name}_origin.bucket_regional_domain_name
    origin_id   = "S3-${name}"

    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.${name}.cloudfront_access_identity_path
    }
  }

  default_cache_behavior {
    allowed_methods        = ["GET", "HEAD", "OPTIONS"]
    cached_methods         = ["GET", "HEAD"]
    target_origin_id       = "S3-${name}"
    viewer_protocol_policy = "redirect-to-https"
    compress               = true

    cache_policy_id          = aws_cloudfront_cache_policy.${name}.id
    origin_request_policy_id = aws_cloudfront_origin_request_policy.${name}.id
  }

  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }

  viewer_certificate {
    cloudfront_default_certificate = true
  }

  tags = {
    Name = "${name}"
  }
}

resource "aws_cloudfront_origin_access_identity" "${name}" {
  comment = "${name} OAI"
}

resource "aws_cloudfront_cache_policy" "${name}" {
  name        = "${name}-cache-policy"
  default_ttl = 86400
  max_ttl     = 31536000
  min_ttl     = 0

  parameters_in_cache_key_and_forwarded_to_origin {
    cookies_config {
      cookie_behavior = "none"
    }
    headers_config {
      header_behavior = "none"
    }
    query_strings_config {
      query_string_behavior = "none"
    }
  }
}

resource "aws_cloudfront_origin_request_policy" "${name}" {
  name = "${name}-origin-request-policy"

  cookies_config {
    cookie_behavior = "none"
  }
  headers_config {
    header_behavior = "none"
  }
  query_strings_config {
    query_string_behavior = "none"
  }
}

`;
}

function generateGCPInfra(config: {
  name: string;
  project: string;
  region?: string;
}): string {
  const { name, project, region = 'us-central1' } = config;

  return `# GCP Infrastructure for ${name}

terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = "${project}"
  region  = "${region}"
}

# VPC Network
resource "google_compute_network" "${name}" {
  name                    = "${name}-vpc"
  auto_create_subnetworks = false
}

resource "google_compute_subnetwork" "${name}" {
  name          = "${name}-subnet"
  ip_cidr_range = "10.0.0.0/24"
  region        = "${region}"
  network       = google_compute_network.${name}.id

  secondary_ip_range {
    range_name    = "pods"
    ip_cidr_range = "10.1.0.0/16"
  }

  secondary_ip_range {
    range_name    = "services"
    ip_cidr_range = "10.2.0.0/20"
  }
}

# GKE Cluster
resource "google_container_cluster" "${name}" {
  name     = "${name}-cluster"
  location = "${region}"

  network    = google_compute_network.${name}.name
  subnetwork = google_compute_subnetwork.${name}.name

  remove_default_node_pool = true
  initial_node_count       = 1

  ip_allocation_policy {
    cluster_secondary_range_name  = "pods"
    services_secondary_range_name = "services"
  }

  workload_identity_config {
    workload_pool = "${project}.svc.id.goog"
  }
}

resource "google_container_node_pool" "${name}" {
  name       = "${name}-node-pool"
  location   = "${region}"
  cluster    = google_container_cluster.${name}.name
  node_count = 2

  node_config {
    preemptible  = false
    machine_type = "e2-medium"

    oauth_scopes = [
      "https://www.googleapis.com/auth/cloud-platform"
    ]
  }

  autoscaling {
    min_node_count = 1
    max_node_count = 5
  }
}

# Cloud SQL
resource "google_sql_database_instance" "${name}" {
  name             = "${name}-db"
  database_version = "POSTGRES_15"
  region           = "${region}"

  settings {
    tier = "db-f1-micro"

    backup_configuration {
      enabled = true
    }

    ip_configuration {
      ipv4_enabled = false
      private_network = google_compute_network.${name}.id
    }
  }

  deletion_protection = var.environment == "prod"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}
`;
}

function generateAzureInfra(config: {
  name: string;
  location?: string;
}): string {
  const { name, location = 'eastus' } = config;

  return `# Azure Infrastructure for ${name}

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

# Resource Group
resource "azurerm_resource_group" "${name}" {
  name     = "${name}-rg"
  location = "${location}"

  tags = {
    Environment = var.environment
    Project     = "${name}"
  }
}

# Virtual Network
resource "azurerm_virtual_network" "${name}" {
  name                = "${name}-vnet"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.${name}.location
  resource_group_name = azurerm_resource_group.${name}.name
}

resource "azurerm_subnet" "${name}_app" {
  name                 = "app-subnet"
  resource_group_name  = azurerm_resource_group.${name}.name
  virtual_network_name = azurerm_virtual_network.${name}.name
  address_prefixes     = ["10.0.1.0/24"]
}

resource "azurerm_subnet" "${name}_db" {
  name                 = "db-subnet"
  resource_group_name  = azurerm_resource_group.${name}.name
  virtual_network_name = azurerm_virtual_network.${name}.name
  address_prefixes     = ["10.0.2.0/24"]

  service_endpoints = ["Microsoft.Sql"]
}

# AKS Cluster
resource "azurerm_kubernetes_cluster" "${name}" {
  name                = "${name}-aks"
  location            = azurerm_resource_group.${name}.location
  resource_group_name = azurerm_resource_group.${name}.name
  dns_prefix          = "${name}"

  default_node_pool {
    name       = "default"
    node_count = 2
    vm_size    = "Standard_D2_v2"
  }

  identity {
    type = "SystemAssigned"
  }

  network_profile {
    network_plugin = "azure"
  }
}

# Azure SQL Database
resource "azurerm_mssql_server" "${name}" {
  name                         = "${name}-sqlserver"
  resource_group_name          = azurerm_resource_group.${name}.name
  location                     = azurerm_resource_group.${name}.location
  version                      = "12.0"
  administrator_login          = "sqladmin"
  administrator_login_password = var.sql_password

  minimum_tls_version = "1.2"
}

resource "azurerm_mssql_database" "${name}" {
  name           = "${name}-db"
  server_id      = azurerm_mssql_server.${name}.id
  collation      = "SQL_Latin1_General_CP1_CI_AS"
  max_size_gb    = 2
  sku_name       = "S0"
  zone_redundant = false
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "dev"
}

variable "sql_password" {
  description = "SQL Server admin password"
  type        = string
  sensitive   = true
}
`;
}

function generateModules(type: 'vpc' | 'database' | 'kubernetes' | 'serverless'): Record<string, unknown> {
  const modules: Record<string, Record<string, unknown>> = {
    vpc: {
      source: 'terraform-aws-modules/vpc/aws',
      version: '~> 5.0',
      example: `module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "my-vpc"
  cidr = "10.0.0.0/16"

  azs             = ["us-east-1a", "us-east-1b", "us-east-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway = true
  single_nat_gateway = true

  enable_dns_hostnames = true
  enable_dns_support   = true
}`,
      documentation: 'https://registry.terraform.io/modules/terraform-aws-modules/vpc/aws'
    },
    database: {
      source: 'terraform-aws-modules/rds/aws',
      version: '~> 6.0',
      example: `module "db" {
  source  = "terraform-aws-modules/rds/aws"
  version = "~> 6.0"

  identifier = "my-database"

  engine            = "postgres"
  engine_version    = "15"
  instance_class    = "db.t3.micro"
  allocated_storage = 20

  db_name  = "mydb"
  username = "admin"
  port     = "5432"

  vpc_security_group_ids = [module.security_group.security_group_id]
  subnet_ids            = module.vpc.private_subnets

  family = "postgres15"
  major_engine_version = "15"

  deletion_protection = false
}`,
      documentation: 'https://registry.terraform.io/modules/terraform-aws-modules/rds/aws'
    },
    kubernetes: {
      source: 'terraform-aws-modules/eks/aws',
      version: '~> 19.0',
      example: `module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "~> 19.0"

  cluster_name    = "my-cluster"
  cluster_version = "1.28"

  vpc_id                   = module.vpc.vpc_id
  subnet_ids               = module.vpc.private_subnets
  control_plane_subnet_ids = module.vpc.intra_subnets

  eks_managed_node_groups = {
    default = {
      min_size     = 1
      max_size     = 3
      desired_size = 2

      instance_types = ["t3.medium"]
    }
  }
}`,
      documentation: 'https://registry.terraform.io/modules/terraform-aws-modules/eks/aws'
    },
    serverless: {
      source: 'terraform-aws-modules/lambda/aws',
      version: '~> 6.0',
      example: `module "lambda" {
  source  = "terraform-aws-modules/lambda/aws"
  version = "~> 6.0"

  function_name = "my-function"
  handler       = "index.handler"
  runtime       = "nodejs18.x"

  source_path = "./src/lambda"

  environment_variables = {
    ENVIRONMENT = "production"
  }

  attach_policy_json = true
  policy_json        = data.aws_iam_policy_document.lambda_policy.json
}`,
      documentation: 'https://registry.terraform.io/modules/terraform-aws-modules/lambda/aws'
    }
  };

  return modules[type] || { error: 'Unknown module type', available: Object.keys(modules) };
}

export const terraformGenTool: UnifiedTool = {
  name: 'terraform_gen',
  description: 'Terraform Generator: aws, gcp, azure, modules',
  parameters: {
    type: 'object',
    properties: {
      operation: { type: 'string', enum: ['aws', 'gcp', 'azure', 'modules'] },
      config: { type: 'object' },
      type: { type: 'string' }
    },
    required: ['operation']
  },
};

export async function executeTerraformGen(toolCall: UnifiedToolCall): Promise<UnifiedToolResult> {
  const { id, arguments: rawArgs } = toolCall;
  try {
    const args = typeof rawArgs === 'string' ? JSON.parse(rawArgs) : rawArgs;
    let result: Record<string, unknown> | string;

    switch (args.operation) {
      case 'aws':
        result = {
          terraform: generateAWSInfra(args.config || {
            name: 'myapp',
            region: 'us-east-1',
            resources: [
              { type: 'vpc', name: 'main' },
              { type: 's3', name: 'assets' },
              { type: 'lambda', name: 'api' }
            ]
          }),
          commands: [
            'terraform init',
            'terraform plan',
            'terraform apply'
          ]
        };
        break;
      case 'gcp':
        result = {
          terraform: generateGCPInfra(args.config || {
            name: 'myapp',
            project: 'my-project-id',
            region: 'us-central1'
          }),
          commands: [
            'terraform init',
            'terraform plan',
            'terraform apply'
          ]
        };
        break;
      case 'azure':
        result = {
          terraform: generateAzureInfra(args.config || {
            name: 'myapp',
            location: 'eastus'
          }),
          commands: [
            'terraform init',
            'terraform plan',
            'terraform apply'
          ]
        };
        break;
      case 'modules':
        result = generateModules((args.type || 'vpc') as 'vpc' | 'database' | 'kubernetes' | 'serverless');
        break;
      default:
        throw new Error(`Unknown operation: ${args.operation}`);
    }

    return { toolCallId: id, content: typeof result === 'string' ? result : JSON.stringify(result, null, 2) };
  } catch (e) {
    return { toolCallId: id, content: `Error: ${e instanceof Error ? e.message : 'Unknown'}`, isError: true };
  }
}

export function isTerraformGenAvailable(): boolean { return true; }
